
/**
 * contains and manages the state for an slide
 */
cdb.admin.Slide = cdb.core.Model.extend({

  initialize: function() {
    this.bind('change:map', this._bindMap);
  },

  getForObj: function(obj, attr) {
    return this.get(obj.cid + "_" + attr);
  },

  setForObj: function(obj, attr, value) {
    return this.set(obj.cid + "_" + attr, value);
  },

  _trackObject: function(obj, properties, serialize, force_properties) {
    force_properties = force_properties || [];

    var self = this;

    function toObjAttrs(attrs) {
      var attr = {};
      _.each(_.pick(attrs, properties), function(v, k) {
        attr[obj.cid + "_" + k] = v;
      });
      return attr;
    }

    function copyAttr(attrs) {
      self.set(toObjAttrs(attrs));
    }

    // copy current state
    copyAttr(obj.attributes);

    // change state when slide changes
    this.bind('change:active', function() {
      if (this.isActive()) {
        var changes = {};
        for (var p in properties) {
          var prop = properties[p];
          if (this.has(obj.cid + "_" + prop)) {
            changes[prop] = this.getForObj(obj, prop);
          }
        }
        if (Object.keys(changes).length) {
          if (serialize) {
            serialize(_.pick(changes, properties));
          } else {
            obj.set(changes);
          }
        }
      }
    });

    var listen = properties.map(function(p) {
      return 'change:' + p;
    }).join(' ');

    obj.bind(listen, function() {
      if (this.isActive()) {
        copyAttr(
          _.extend({},
            obj.changedAttributes(),
           _.pick(obj.attributes, force_properties)
          )
        );
      }
    }, this);

    obj.bind('destroy', function() {
      obj.unbind(listen + " destroy", null, this);
      //TODO: unset all the properties related to this object
    }, this);

  },

  _bindMap: function(map) {
    this.map = this.get('map');
    this._trackObject(this.map, ['center', 'zoom']);
    this.map.layers.each(this._bindLayer.bind(this));
  },


  // track sql, cartocss
  _bindLayer: function(layer) {
    var trackedProperties = ['tile_style', 'query', 'wizard_properties', 'filters', 'tile_style_custom', 'infowindow', 'legends'];

    this._trackObject(layer, trackedProperties, function(attrs) {
      // when filters are present don't apply sql query
      // it will be generated by filters
      var applyQuery = null;
      if (attrs.filter) {
        delete attrs.query;
      }
      if (attrs.query) {
        applyQuery = attrs.query;
      }

      if (attrs.tile_style_custom) {
      }

      // don't change query directly, use applySQLView
      delete attrs.query;

      // infowindow
      layer.infowindow.set(attrs.infowindow);
      delete attrs.infowindow;

      if (applyQuery) {
        layer.applySQLView(applyQuery);
      } else {
        layer.clearSQLView();
      }



      layer.set(attrs);

    }, 'wizard_properties');
  },

  isActive: function() {
    return !!this.get('active');
  }

});

/**
 * slide collection
 */
cdb.admin.Slides = Backbone.Collection.extend({

  model: cdb.admin.Slide,

  initialize: function(models, options) {
    if (!options || !options.map) {
      throw new Error("map is undefined");
    }

    this.map = options.map;

    var self = this;
    var _setMap = function(m) { 
      m.set('map', self.map);
    };
    this.bind('add', _setMap, this);
    this.bind('reset', function() { this.each(_setMap); }, this);
  },

  setActive: function(slide) {
    var active = this.find(function (s) {
      return s.get('active');
    });
    if (active) {
      active.set('active', false);
    }
    slide.set('active', true);
  }



});
